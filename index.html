<html>
  <head>
    <!-- Contributors to this project include
          Joseph Fuentes jrf268 Joanna Saikali js3548 Sawyer Hwang  -->

    <title> Project 1 </title>
    <script src="https://d3js.org/d3.v6.min.js"></script>

  </head>

  <body>
    <h3 style="color:darkblue; font-family:Arial;"> WallStreetBets Gamestop chatter versus GME trading value </h3>

    <svg id= "barchart" width="800" height="600" style="border: 1px solid black"> </svg>

    <script>

    const svg = d3.select("svg#barchart");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margins = {"top":10, "right":40, "bottom":40, "left":40};
    const chartWidth = width - margins.left - margins.right;
    const chartHeight = height - margins.top - margins.bottom;

    let annotations = svg.append("g").attr("id","annotations");

    let barChart = svg.append("g")
                    .attr("transform","translate("+margins.left+","+margins.top+")");

    //for GME Stock Data
    d3.csv("GME_Stock_Data.csv").then( (data) =>{
      const timeParser =d3.timeParse('%Y-%m-%d')
      //filter data
      data.forEach( (d, i) => {

          d["volNum"] = Number(d['Volume']);
          d["openNum"] = Number(d["Open"]);
          d["closeNum"] = Number(d["Close"]);
          d["dateNum"] = Number(d["Date"].replace(/-/g,""));
          d['d3Date'] = timeParser(d["Date"]);
          d["highLow"] = d["openNum"]-d["closeNum"];

      })
      //filter out dates before 01/28
      data = data.filter( (d) => {return d["dateNum"] > 20210127; } );
      console.log("stock volume: ")
      console.log(data);

  //ADD WEEKEND values
  //based off code from https://github.com/d3/d3-time-format

  //Simple way ~

  //Once new entries are pushed to dataset array, they appear as empty bars
  //at the far right of the graph. The date scale does not recognize that they
  //fit within the existing bars and should be in their intended date. Seems like a quick fix.

      // var parseTime = d3.timeParse("%j, %Y %Z")

      // data.push( {"d3Date": parseTime("030, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("031, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("037, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("038, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("044, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("045, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("046, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("051, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("052, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("058, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("059, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("065, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("066, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("072, 2021 -0400"), "volNum": 0} )
      // data.push( {"d3Date": parseTime("073, 2021 -0400"), "volNum": 0} )

      // console.log("added dates:")
      // console.log(data);

//Ambitious way ~

//I thought it was worth a shot.

      // for (var i = 0; i < data.length-1; i++) {
      //
      //     const lowCounter = data[i]['d3Date'];
      //     const hiCounter = data[i+1]['d3Date'];

      //     const formatDay = d3.timeFormat("%j")
      //     console.log(formatDay(lowCounter));
      //     //console.log(Number(formatDay(hiCounter)) - Number(formatDay(lowCounter)));
      //     const daysMissing = Number(formatDay(hiCounter)) - Number(formatDay(lowCounter));
      //     //console.log(daysMissing);
      //     if ( daysMissing >1) {
      //
      //         data.push( { "Date": d3.timeParse("%j")(new Date), "Volume": 0 } )
      //
      //     }
      //     console.log("post date adds")
      //     console.log(data);
      //     //if (counter)
      // }

      //build Scales
      const volumeExtent = d3.extent(data, d => d["volNum"] );
      const volumeScale = d3.scaleLinear().domain(volumeExtent).range([chartHeight, 0]);

      //date scales for bar chart based off 21.03.15 lecture notes (genreScale)
      const dates = d3.map(data, d => d.d3Date)
      //const dateExtent = d3.extent(data, d=> d["d3Date"] );

      const dateScale1 = d3.scaleTime().domain(dates).range([0, chartWidth] );
      const dateScale = d3.scaleBand().domain(dates).range([0, chartWidth] )
                                      .padding(0.0);

      //color scale
      const minMax = d3.extent(data, d => d["highLow"])
      const colorScale = d3.scaleSequential(d3.interpolateRdBu).domain(minMax);

      let leftAxis = d3.axisLeft(volumeScale)
                        .tickFormat(d3.format("~s"));

      let leftGridlines = d3.axisLeft(volumeScale)
                            .tickSize(-chartWidth)
                            .tickFormat("")

      //Y Left Axis
      annotations.append("g")
           .attr("class", "y gridlines")
           .attr("transform","translate("+margins.left+","+margins.top+")")
           .attr("color","lightgrey")
           .call(leftGridlines);

      annotations.append("g")
                .attr("class", "yLeftaxis")
                .attr("transform", "translate("+margins.left+", "+margins.top+" )" )
                .call(leftAxis)
      //console.log("volumeScale")
      data.forEach( (d, i) => {
        //console.log(volumeScale(10000))
        //console.log(volumeScale(d.volNum))
      })
      //add bars
      barChart.selectAll("rect.bar").data(data)
                                .join("rect").attr("class", "bar")
                                .attr("fill", d => colorScale(d.highLow))
                                .attr("x", d => dateScale(d.d3Date))
                                .attr("y", d => volumeScale(d.volNum))
                                .attr("height", d => height-margins.bottom-10-volumeScale(d.volNum))
                                .attr("width", dateScale.bandwidth());

    })

    d3.csv("WSB_gamestop_mentions.csv").then( (data) =>{
      console.log("chatter: ");
      console.log(data);

      const timeParser =d3.timeParse('%Y-%m-%d')

      data.forEach( (d,i) =>{

          d["mentionsNum"] = Number(d["mentions_GME"] );
          d['d3Date'] = timeParser(d["date"])

      })

      //filter out 01/27
      data = data.filter( (d) => {return d["mentionsNum"] > 0; } );
      console.log(data);

      //build Scales
      const chatterExtent = d3.extent(data, d => d["mentionsNum"] );
      const chatterScale = d3.scaleLog().domain(chatterExtent).range([chartHeight, 0] );

      const dateExtent = d3.extent(data, d=> d["d3Date"] );
      const dateScale = d3.scaleTime().domain(dateExtent).range([0, chartWidth] );

      //X axis
      let bottomAxis = d3.axisBottom(dateScale)
                          .tickFormat(d3.timeFormat("%a %b %d"))

      let bottomGridlines = d3.axisBottom(dateScale)
                              .tickSize(-chartHeight)
                              .tickFormat("")
      annotations.append("g")
                  .attr("class", "x gridlines")
                  .attr("transform", "translate("+margins.left+", "+(chartHeight+margins.top)+")")
                  .attr("color", "lightgrey")
                  .call(bottomGridlines);

      annotations.append("g")
                  .attr("class", "x axis")
                  .attr("transform", "translate("+margins.left+", "+(chartHeight+margins.top+10)+")")
                  .call(bottomAxis);

      //Y Right axis
      let yRightAxis = d3.axisRight(chatterScale)
                          .tickFormat(d3.format("d"))

      annotations.append("g")
                  .attr("class", "yRightAxis")
                  .attr("transform", "translate("+(chartWidth+margins.left)+", "+margins.top+") ")
                  .call(yRightAxis);

      //draw circles; connect with lines
      barChart.selectAll("circle").data(data)
                        .join("circle").attr("class", "points")
                        .attr("cx", d => dateScale(d.d3Date) )
                        .attr("cy", d => chatterScale(d.mentionsNum ) )
                        .attr("r", 3)
                        .attr("fill", "darkpurple");
    })


    </script>

  </body>
</html>
