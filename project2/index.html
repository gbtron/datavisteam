<html>
  <head>
    <!-- Contributors to this project include
          Joseph Fuentes jrf268 Joanna Saikali js3548 Sawyer Hwang  -->

    <title>Project 2</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
    <style>
      .icon,
      .text {
        vertical-align: middle;
        display: inline-block;
      }
      .gridlines line {
      stroke: #bbb;
      }
      .gridlines .domain {
      stroke: none;
      }
      .axis { 
      font: 12px Arial; 
      }
      .state {
        fill: lightgrey;
      }

      .outline {
        stroke: black;
        stroke-width: 1px;
        fill: none;
      }
      
      .mouseover {
        stroke-width: 3px;
        pointer-events: none;
      }

      .graticule {
        fill: none;
        stroke: grey;
        stroke-width: 1px;
      }
      .slider-wrapper {
        width: 20px;
        height: 150px;
        padding: 0;
      }
    </style>
  </head>

  <body>
    <h2 style="color:darkblue; font-family:Arial;"> Singer hometowns per genre </h2>

    <svg id= "map" width="1000" height="800" style="border: 1px solid black"> 
      <text id="label" x="43" y="12" text-anchor="start" alignment-baseline="hanging"></text>
    </svg> <br>

  <div class="row align-items-center">
    <div class="col-sm"><div id="slider-time"></div></div>
  </div>
    <script>

    const svg = d3.select("svg#map");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left:20};
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

    const requestData = async function() {
      const hometownData = await d3.csv("data/hometowns.csv", d3.autotype);
      console.log(hometownData);
      const spotifyFeatures = await d3.csv("data/spotify_features.csv", d3.autotype);
      console.log(spotifyFeatures);
      const spotifyHits = await d3.csv("data/spotify_hits.csv", d3.autotype);
      console.log(spotifyHits);
      const stateIDs = await d3.tsv("data/us-state-names.tsv");
      const us = await d3.json("data/us-smaller.json");

      const yearExtent = d3.extent(spotifyHits, d => d["Year"] )
      const yearRange = d3.range(yearExtent[0],yearExtent[1])

      var states = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);

      var graticule = d3.geoGraticule10();
      map.append("path").attr("class","graticule").attr("d", path(graticule) )
      
      map.selectAll("path.state").data(states.features)
         .join("path")
         .attr("class", "state")
         .attr("note", d => d.id)
         .attr("d", path);
    
      map.append("path").datum(statesMesh)
         .attr("class","outline")
         .attr("d", path);

      // hard coding min and max so it's the same scale regardless of filter
      const colorScale = d3.scaleSequentialLog(d3.interpolateBlues).domain([1,229]);

      let stateCounts = {}; 
      let idToState = {};
      let singerToState = {};

      hometownData.forEach(row => {
        singerToState[row.Artist_Name] = row.State
      })
    
      stateIDs.forEach( row => {
        stateCounts[row.code] = 0;
        idToState[row.id] = row.code;
      });

      function showMap(year){
        // Setting StateCounts to 0s so we re-fill the colors
        let setAll = (obj, val) => Object.keys(obj).forEach(k => obj[k] = val);
        let setZero = obj => setAll(obj, 0);
        setZero(stateCounts)

        map.selectAll(".state").style("fill","white");

        filteredHits = spotifyHits.filter( 
          (d) => {return d["Year"] === year; } )
      
        filteredHits.forEach( row => {
          if (row.Performer in singerToState)
            stateCounts[singerToState[row.Performer]] += 1;
        });
        console.log(stateCounts)

        map.selectAll(".state")
         .style("fill", d => colorScale( stateCounts[ idToState[d.id] ]) );

      }
      showMap("2000")

      // The following is adapted from above;
      // https://bl.ocks.org/johnwalley/e1d256b81e51da68f7feb632a53c3518
      var sliderTime = d3
        .sliderBottom()
        .min(2000)
        .max(2020)
        .step(1)
        .width(300)
        .tickFormat("")
        .tickFormat(d3.format("~f"))
        .ticks(5)
        .default(2000)
        .on('onchange', val => {
          showMap(val.toString());
        });

      var gTime = d3
        .select('div#slider-time')
        .append('svg')
        .attr('width', 500)
        .attr('height', 100)
        .append('g')
        .attr('transform', 'translate(30,30)');

      gTime.call(sliderTime);
      
    }
    requestData();


    </script>

  </body>
</html>
